"""
Database access layer for slack_messages table.

Following Context7 best practices for Supabase CRUD operations.
"""

from typing import Optional
from datetime import datetime
from fastapi import HTTPException
from postgrest.exceptions import APIError

from backend.database.supabase_client import get_supabase_client
from backend.models.slack_message import (
    SlackMessageCreate,
    SlackMessageUpdate,
    SlackMessage,
    SlackMessageListResponse,
    ProcessingStatus,
    CreatedTaskType
)


async def create_slack_message(message_data: SlackMessageCreate, message_id: str) -> SlackMessage:
    """
    Create a new slack message record.

    Args:
        message_data: Message data from request
        message_id: ULID generated by the caller

    Returns:
        Created slack message

    Raises:
        HTTPException: 409 if duplicate slack_ts, 500 if database error
    """
    db = get_supabase_client()

    try:
        data = message_data.model_dump()
        data["message_id"] = message_id

        response = db.table("slack_messages").insert(data).execute()

        if not response.data:
            raise HTTPException(
                status_code=500,
                detail="Failed to create slack message"
            )

        return SlackMessage(**response.data[0])

    except APIError as e:
        if "duplicate key" in str(e).lower() and "slack_ts" in str(e).lower():
            raise HTTPException(
                status_code=409,
                detail="Slack message with this timestamp already exists"
            )
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def get_slack_message_by_id(message_id: str) -> Optional[SlackMessage]:
    """
    Get a slack message by message_id.

    Args:
        message_id: Message ID to retrieve

    Returns:
        Slack message if found, None otherwise
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .select("*")
            .eq("message_id", message_id)
            .is_("deleted_at", "null")
            .execute()
        )

        if not response.data:
            return None

        return SlackMessage(**response.data[0])

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def get_slack_message_by_ts(slack_ts: str) -> Optional[SlackMessage]:
    """
    Get a slack message by Slack timestamp (unique identifier).

    Args:
        slack_ts: Slack message timestamp

    Returns:
        Slack message if found, None otherwise
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .select("*")
            .eq("slack_ts", slack_ts)
            .is_("deleted_at", "null")
            .execute()
        )

        if not response.data:
            return None

        return SlackMessage(**response.data[0])

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def list_slack_messages(
    slack_user_id: Optional[str] = None,
    processing_status: Optional[ProcessingStatus] = None,
    created_task_type: Optional[CreatedTaskType] = None,
    error_message_present: Optional[bool] = None,
    limit: int = 50,
    offset: int = 0
) -> SlackMessageListResponse:
    """
    List slack messages with optional filters.

    Args:
        slack_user_id: Filter by Slack user
        processing_status: Filter by processing status
        created_task_type: Filter by created task type
        error_message_present: Filter by presence of error_message
        limit: Maximum number of results (default 50)
        offset: Number of results to skip (default 0)

    Returns:
        List of slack messages with pagination metadata
    """
    db = get_supabase_client()

    try:
        # Build query
        query = db.table("slack_messages").select("*", count="exact").is_("deleted_at", "null")

        # Apply filters
        if slack_user_id:
            query = query.eq("slack_user_id", slack_user_id)
        if processing_status:
            query = query.eq("processing_status", processing_status.value)
        if created_task_type:
            query = query.eq("created_task_type", created_task_type.value)
        if error_message_present is not None:
            if error_message_present:
                query = query.not_.is_("error_message", "null")
            else:
                query = query.is_("error_message", "null")

        # Apply pagination and ordering
        query = query.order("created_at", desc=True).range(offset, offset + limit - 1)

        response = query.execute()

        messages = [SlackMessage(**item) for item in response.data]
        total = response.count or 0

        return SlackMessageListResponse(
            messages=messages,
            total=total,
            limit=limit,
            offset=offset
        )

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def update_slack_message(message_id: str, message_data: SlackMessageUpdate) -> SlackMessage:
    """
    Update a slack message.

    Args:
        message_id: Message ID to update
        message_data: Fields to update

    Returns:
        Updated slack message

    Raises:
        HTTPException: 404 if not found, 500 if database error
    """
    db = get_supabase_client()

    try:
        # Filter out None values
        data = {k: v for k, v in message_data.model_dump().items() if v is not None}

        if not data:
            # No fields to update, just return current message
            message = await get_slack_message_by_id(message_id)
            if not message:
                raise HTTPException(
                    status_code=404,
                    detail="Slack message not found"
                )
            return message

        response = (
            db.table("slack_messages")
            .update(data)
            .eq("message_id", message_id)
            .is_("deleted_at", "null")
            .execute()
        )

        if not response.data:
            raise HTTPException(
                status_code=404,
                detail="Slack message not found"
            )

        return SlackMessage(**response.data[0])

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def soft_delete_slack_message(message_id: str) -> bool:
    """
    Soft delete a slack message (sets deleted_at timestamp).

    Args:
        message_id: Message ID to delete

    Returns:
        True if deleted, False if not found

    Raises:
        HTTPException: 500 if database error
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .update({"deleted_at": datetime.utcnow().isoformat()})
            .eq("message_id", message_id)
            .is_("deleted_at", "null")
            .execute()
        )

        return len(response.data) > 0

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def get_slack_messages_by_user(slack_user_id: str, limit: int = 100) -> list[SlackMessage]:
    """
    Get all non-deleted messages from a specific Slack user.

    Args:
        slack_user_id: Slack user ID
        limit: Maximum number of messages to return (default 100)

    Returns:
        List of slack messages
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .select("*")
            .eq("slack_user_id", slack_user_id)
            .is_("deleted_at", "null")
            .order("created_at", desc=True)
            .limit(limit)
            .execute()
        )

        return [SlackMessage(**item) for item in response.data]

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def get_pending_slack_messages(limit: int = 50) -> list[SlackMessage]:
    """
    Get all pending (unprocessed) slack messages.

    Args:
        limit: Maximum number of messages to return (default 50)

    Returns:
        List of pending slack messages
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .select("*")
            .eq("processing_status", ProcessingStatus.PENDING.value)
            .is_("deleted_at", "null")
            .order("created_at", desc=False)  # Process oldest first
            .limit(limit)
            .execute()
        )

        return [SlackMessage(**item) for item in response.data]

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def get_failed_slack_messages(limit: int = 50) -> list[SlackMessage]:
    """
    Get all failed slack messages for retry/debugging.

    Args:
        limit: Maximum number of messages to return (default 50)

    Returns:
        List of failed slack messages
    """
    db = get_supabase_client()

    try:
        response = (
            db.table("slack_messages")
            .select("*")
            .eq("processing_status", ProcessingStatus.FAILED.value)
            .is_("deleted_at", "null")
            .order("created_at", desc=True)
            .limit(limit)
            .execute()
        )

        return [SlackMessage(**item) for item in response.data]

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def mark_slack_message_processed(
    message_id: str,
    created_listing_id: Optional[str] = None,
    created_task_id: Optional[str] = None,
    created_task_type: Optional[CreatedTaskType] = None
) -> SlackMessage:
    """
    Mark a slack message as processed and record what was created.

    Args:
        message_id: Message ID to update
        created_listing_id: Optional listing ID that was created
        created_task_id: Optional task ID that was created
        created_task_type: Optional task type that was created

    Returns:
        Updated slack message

    Raises:
        HTTPException: 404 if not found, 500 if database error
    """
    db = get_supabase_client()

    try:
        update_data = {
            "processing_status": ProcessingStatus.PROCESSED.value,
            "processed_at": datetime.utcnow().isoformat()
        }

        if created_listing_id:
            update_data["created_listing_id"] = created_listing_id
        if created_task_id:
            update_data["created_task_id"] = created_task_id
        if created_task_type:
            update_data["created_task_type"] = created_task_type.value

        response = (
            db.table("slack_messages")
            .update(update_data)
            .eq("message_id", message_id)
            .is_("deleted_at", "null")
            .execute()
        )

        if not response.data:
            raise HTTPException(
                status_code=404,
                detail="Slack message not found"
            )

        return SlackMessage(**response.data[0])

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )


async def mark_slack_message_failed(message_id: str, error_message: str) -> SlackMessage:
    """
    Mark a slack message as failed with error details.

    Args:
        message_id: Message ID to update
        error_message: Error message to record

    Returns:
        Updated slack message

    Raises:
        HTTPException: 404 if not found, 500 if database error
    """
    db = get_supabase_client()

    try:
        update_data = {
            "processing_status": ProcessingStatus.FAILED.value,
            "error_message": error_message,
            "processed_at": datetime.utcnow().isoformat()
        }

        response = (
            db.table("slack_messages")
            .update(update_data)
            .eq("message_id", message_id)
            .is_("deleted_at", "null")
            .execute()
        )

        if not response.data:
            raise HTTPException(
                status_code=404,
                detail="Slack message not found"
            )

        return SlackMessage(**response.data[0])

    except APIError as e:
        raise HTTPException(
            status_code=500,
            detail=f"Database error: {str(e)}"
        )
